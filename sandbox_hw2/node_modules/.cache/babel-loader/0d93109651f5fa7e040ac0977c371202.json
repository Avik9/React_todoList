{"ast":null,"code":"'strict mode';\n/**\n * jsTPS_Transaction.java\n * \n * This interface provides the structure that all transactions to be\n * managed by jsTPS must follow. Each transaction must have defined\n * behavior for do and undo. Note that when defining custom transaction\n * classes one needs to make sure the constructor is given the objects\n * it will need to manipulate at the time the do and undo methods\n * are called.\n * \n * @author Avik Kadakia\n * @version 1.0\n */\n\nclass jsTPS_Transaction {\n  constructor() {}\n  /**\n  * This method is called by jsTPS when a transaction is executed.\n  */\n\n\n  doTransaction() {\n    window.alert('Inheritance did not work and you are printing from the \"Interface\"');\n  }\n  /**\n  * This method is called by jTPS when a transaction is undone.\n  */\n\n\n  undoTransaction() {\n    window.alert('Inheritance did not work and you are printing from the \"Interface\"');\n  }\n\n}\n/**\n * jsTPS.js\n * \n * This class is used for managing an abstract transaction processing\n * system for the purpose of managing an undo/redo system for an\n * application. Note that one must specify all work done via custom\n * transactions.\n *\n */\n\n\nclass jsTPS {\n  constructor() {\n    // THE TRANSACTION STACK\n    this.transactions = []; // KEEPS TRACK OF WHERE WE ARE IN THE STACK, THUS AFFECTING WHAT\n    // TRANSACTION MAY BE DONE OR UNDONE AT ANY GIVEN TIME\n\n    this.mostRecentTransaction = -1; // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n    // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n\n    this.performingDo = false;\n    this.performingUndo = false;\n  }\n  /**\n   * Tests to see if the do (i.e. redo) operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the do (i.e. redo) operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingDo() {\n    return this.performingDo;\n  }\n  /**\n   * Tests to see if the undo operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the undo operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingUndo() {\n    return this.performingUndo;\n  }\n  /**\n   * This function adds the transaction argument to the top of\n   * the transaction processing system stack and then executes it. Note that it does\n   * When this method has completed transaction will be at the top \n   * of the stack, it will have been completed, and the counter have\n   * been moved accordingly.\n   * \n   * @param transaction The custom transaction to be added to\n   * the transaction processing system stack and executed.\n   */\n\n\n  addTransaction(transaction) {\n    // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n    // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n    if (this.mostRecentTransaction < 0 || this.mostRecentTransaction < this.transactions.length - 1) {\n      for (let i = this.transactions.length - 1; i > this.mostRecentTransaction; i--) {\n        this.transactions.slice(i);\n      }\n    } // AND NOW ADD THE TRANSACTION\n\n\n    this.transactions.push(transaction); // AND EXECUTE IT\n\n    this.doTransaction();\n  }\n  /**\n   * This function executes the transaction at the location of the counter,\n   * then moving the TPS counter. Note that this may be the transaction\n   * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n   */\n\n\n  doTransaction() {\n    if (this.hasTransactionToRedo()) {\n      this.performingDo = true;\n      let transaction = this.transactions[this.mostRecentTransaction + 1];\n      transaction.doTransaction();\n      this.mostRecentTransaction++;\n      this.performingDo = false;\n    }\n  }\n  /**\n   * This function gets the most recently executed transaction on the \n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n\n\n  undoTransaction() {\n    if (this.hasTransactionToUndo()) {\n      this.performingUndo = true;\n      let transaction = this.transactions[this.mostRecentTransaction];\n      transaction.undoTransaction();\n      this.mostRecentTransaction--;\n      this.performingUndo = false;\n    }\n  }\n  /**\n   * This method clears all transactions from the TPS stack\n   * and resets the counter that keeps track of the location\n   * of the top of the stack.\n   */\n\n\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = []; // MAKE SURE TO RESET THE LOCATION OF THE\n    // TOP OF THE TPS STACK TOO\n\n    this.mostRecentTransaction = -1;\n  }\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * @return The number of transactions currently in the transaction stack.\n   */\n\n\n  getSize() {\n    return this.transactions.length;\n  }\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * @return The number of transactions currently in the transaction stack.\n   */\n\n\n  getNumTrasactionsToUndo() {\n    return this.mostRecentTransaction + 1;\n  }\n  /**\n   * This method returns the number of transactions currently in the\n   * transaction stack that can be redone, meaning they have been added\n   * and done, and then undone.\n   * \n   * @return The number of transactions in the stack that can be redone.\n   */\n\n\n  getRedoSize() {\n    return this.getSize() - this.mostRecentTransaction - 1;\n  }\n  /**\n   * This method returns the number of transactions currently in the \n   * transaction stack that can be undone.\n   * \n   * @return The number of transactions in the transaction stack that\n   * can be undone.\n   */\n\n\n  getUndoSize() {\n    return this.mostRecentTransaction + 1;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be undone at the time this function is called.\n   * \n   * @return true if an undo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToUndo() {\n    return this.mostRecentTransaction >= 0;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be redone at the time this function is called.\n   * \n   * @return true if a redo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToRedo() {\n    return this.mostRecentTransaction < this.getSize() - 1;\n  }\n  /**\n   * This method builds and returns a textual summary of the current\n   * Transaction Processing System, this includes the toString of\n   * each transaction in the stack.\n   * \n   * @return A textual summary of the TPS.\n   */\n\n\n  toString() {\n    let text = \"--Number of Transactions: \" + this.getSize() + \"<br>\";\n    text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"<br>\";\n    text += \"--Current Transaction Stack:<br>\";\n\n    for (let i = 0; i <= this.mostRecentTransaction; i++) {\n      let jT = this.transactions.get(i);\n      text += \"----\" + jT.toString() + \"<br>\";\n    }\n\n    return text;\n  }\n\n}","map":{"version":3,"sources":["/Users/avik/Desktop/My Stuff/SBU/Junior Year/Fall 2019/CSE 316/Homework 2/sandbox_todo/sandbox_hw2/src/components/jsTPS/jsTPS_Transaction.js"],"names":["jsTPS_Transaction","constructor","doTransaction","window","alert","undoTransaction","jsTPS","transactions","mostRecentTransaction","performingDo","performingUndo","isPerformingDo","isPerformingUndo","addTransaction","transaction","length","i","slice","push","hasTransactionToRedo","hasTransactionToUndo","clearAllTransactions","getSize","getNumTrasactionsToUndo","getRedoSize","getUndoSize","toString","text","jT","get"],"mappings":"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","sourcesContent":["'strict mode'\n\n/**\n * jsTPS_Transaction.java\n * \n * This interface provides the structure that all transactions to be\n * managed by jsTPS must follow. Each transaction must have defined\n * behavior for do and undo. Note that when defining custom transaction\n * classes one needs to make sure the constructor is given the objects\n * it will need to manipulate at the time the do and undo methods\n * are called.\n * \n * @author Avik Kadakia\n * @version 1.0\n */\n\nclass jsTPS_Transaction {\n\n  constructor()\n  {\n      \n  }\n\n  /**\n  * This method is called by jsTPS when a transaction is executed.\n  */\n    doTransaction() {\n    window.alert('Inheritance did not work and you are printing from the \"Interface\"');\n  }\n\n  /**\n  * This method is called by jTPS when a transaction is undone.\n  */\n    undoTransaction () {\n    window.alert('Inheritance did not work and you are printing from the \"Interface\"');\n  }\n}\n\n\n/**\n * jsTPS.js\n * \n * This class is used for managing an abstract transaction processing\n * system for the purpose of managing an undo/redo system for an\n * application. Note that one must specify all work done via custom\n * transactions.\n *\n */\nclass jsTPS{\n\n  constructor()\n  {\n      // THE TRANSACTION STACK\n      this.transactions = [];\n\n      // KEEPS TRACK OF WHERE WE ARE IN THE STACK, THUS AFFECTING WHAT\n      // TRANSACTION MAY BE DONE OR UNDONE AT ANY GIVEN TIME\n      this.mostRecentTransaction = -1;\n\n      // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n      // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n      this.performingDo = false;\n      this.performingUndo = false;\n  }\n\n  /**\n   * Tests to see if the do (i.e. redo) operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the do (i.e. redo) operation is currently in the\n   * process of executing, false otherwise.\n   */\n  isPerformingDo()\n  {\n      return this.performingDo;\n  }\n\n  /**\n   * Tests to see if the undo operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the undo operation is currently in the\n   * process of executing, false otherwise.\n   */\n  isPerformingUndo()\n  {\n      return this.performingUndo;\n  }\n\n  /**\n   * This function adds the transaction argument to the top of\n   * the transaction processing system stack and then executes it. Note that it does\n   * When this method has completed transaction will be at the top \n   * of the stack, it will have been completed, and the counter have\n   * been moved accordingly.\n   * \n   * @param transaction The custom transaction to be added to\n   * the transaction processing system stack and executed.\n   */\n  addTransaction(transaction)\n  {\n      // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n      // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n      if((this.mostRecentTransaction < 0) || ((this.mostRecentTransaction) < (this.transactions.length - 1)))\n      {\n          for(let i = this.transactions.length - 1; i > this.mostRecentTransaction; i--)\n          {\n              this.transactions.slice(i);\n          }\n      }\n\n      // AND NOW ADD THE TRANSACTION\n      this.transactions.push(transaction);\n\n      // AND EXECUTE IT\n      this.doTransaction(); \n  }\n   \n  /**\n   * This function executes the transaction at the location of the counter,\n   * then moving the TPS counter. Note that this may be the transaction\n   * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n   */\n  \n  doTransaction() {\n      if (this.hasTransactionToRedo()) {\n          this.performingDo = true;\n          let transaction = this.transactions[this.mostRecentTransaction+1];\n          transaction.doTransaction();\n          this.mostRecentTransaction++;\n          this.performingDo = false;\n      }\n  }\n\n  /**\n   * This function gets the most recently executed transaction on the \n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n  undoTransaction() {\n      if (this.hasTransactionToUndo()) {\n          this.performingUndo = true;\n          let transaction = this.transactions[this.mostRecentTransaction];\n          transaction.undoTransaction();\n          this.mostRecentTransaction--;\n          this.performingUndo = false;\n      }\n  }\n\n  /**\n   * This method clears all transactions from the TPS stack\n   * and resets the counter that keeps track of the location\n   * of the top of the stack.\n   */\n  clearAllTransactions() {\n      // REMOVE ALL THE TRANSACTIONS\n      this.transactions = [];\n      \n      // MAKE SURE TO RESET THE LOCATION OF THE\n      // TOP OF THE TPS STACK TOO\n      this.mostRecentTransaction = -1;        \n  }\n\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * @return The number of transactions currently in the transaction stack.\n   */\n  getSize() {\n      return this.transactions.length;\n  }\n\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * @return The number of transactions currently in the transaction stack.\n   */\n  getNumTrasactionsToUndo() {\n    return this.mostRecentTransaction + 1;\n}\n\n  /**\n   * This method returns the number of transactions currently in the\n   * transaction stack that can be redone, meaning they have been added\n   * and done, and then undone.\n   * \n   * @return The number of transactions in the stack that can be redone.\n   */\n  getRedoSize() {\n      return this.getSize() - this.mostRecentTransaction - 1;\n  }\n\n  /**\n   * This method returns the number of transactions currently in the \n   * transaction stack that can be undone.\n   * \n   * @return The number of transactions in the transaction stack that\n   * can be undone.\n   */\n  getUndoSize() {\n      return this.mostRecentTransaction + 1;\n  }\n\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be undone at the time this function is called.\n   * \n   * @return true if an undo operation is possible, false otherwise.\n   */\n  hasTransactionToUndo() {\n      return this.mostRecentTransaction >= 0;\n  }\n\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be redone at the time this function is called.\n   * \n   * @return true if a redo operation is possible, false otherwise.\n   */\n  hasTransactionToRedo() {\n      return this.mostRecentTransaction < (this.getSize()-1);\n  }\n\n  /**\n   * This method builds and returns a textual summary of the current\n   * Transaction Processing System, this includes the toString of\n   * each transaction in the stack.\n   * \n   * @return A textual summary of the TPS.\n   */\n  toString() {\n      let text = \"--Number of Transactions: \" + this.getSize() + \"<br>\";\n      text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"<br>\";\n      text += \"--Current Transaction Stack:<br>\";\n      for (let i = 0; i <= this.mostRecentTransaction; i++) {\n          let jT = this.transactions.get(i);\n          text += \"----\" + jT.toString() + \"<br>\";\n      }\n      return text;\n  }\n}"]},"metadata":{},"sourceType":"module"}